<script type="module">
  // -------------------------------------------------------------------------------------
  // * Fetch number of revisions
  // -------------------------------------------------------------------------------------
  const usedSlots = document.querySelectorAll(".slot-num-revisions")
  const fileIds = Array.from(usedSlots,
    el => el.closest('article')
      .dataset['fileId'])

  for (const slot of usedSlots)
    slot.classList.add('throbber')

  const BATCH_SIZE = 10
  for (let i = 0; i < fileIds.length; i += BATCH_SIZE) (async () => { /* captures i */
    const slice = fileIds.slice(i, i + BATCH_SIZE)

    LOG(`Asking for revisions for ${slice.length} files`)

    const bulkRevisions = await CALL.getRevisionsInBulk(slice)

    LOG(`Yay[${i}-${i + slice.length}]!  # = ${bulkRevisions.length}`)

    for (const [j, revisions] of bulkRevisions.entries()) {
      const numRevsEl = usedSlots[i + j]
      numRevsEl.classList.remove('throbber')
      numRevsEl.innerHTML = `<b>${revisions.length}</b> of ${revisions.length} revisions`
    }
  })()


  // -------------------------------------------------------------------------------------
  // * Make the mouse wheel horizontally scroll <main>
  // -------------------------------------------------------------------------------------


  class WheelHandler {
    static GAME_WIDTH = document.querySelector("article.uh").offsetWidth
    static INSTANT_SCROLL_MS = 400
    #lastTimeStamp = 0

    static isScrollable(node) {
      if (node.nodeType !== Node.ELEMENT_NODE) {
        return false
      }
      const overflowY = getComputedStyle(element).overflowY
      const doesCSSOverflow = ['overflow', 'auto'].includes(overflowY)
      const isOverflowing = element.scrollHeight > element.clientHeight
      return doesCSSOverflow && isOverflowing
    }

    static ignoreEvent(event) {
      if (event.shiftKey) {
        return true
      }
      if (event.composedPath().some(WheelHandler.isScrollable)) {
        return true
      }
      return false
    }

    updateTimeStamp(ts) {
      const dt = this.#lastTimeStamp - ts
      this.#lastTimeStamp = ts
      return dt
    }

    handleEvent(event) {
      if (WheelHandler.ignoreEvent(event)) {
        return
      }

      const scrollAmount = Math.sign(event.deltaY) * WheelHandler.GAME_WIDTH

      const dt = this.updateTimeStamp(event.timeStamp)
      const behavior = dt < WheelHandler.INSTANT_SCROLL_MS
                     ? "instant"
                     : "smooth"

      document.documentElement.scrollBy({
        left: scrollAmount,
        behavior
      })

      this.#lastTimeStamp = event.timeStamp
    }
  }

  window.addEventListener("wheel", new WheelHandler(), { passive: true })

</script>